## 최소공약수(GCD)
### 유클리드 호제법
==**유클리드 호제법**==이란 서로 다른 두 수를 연달아 빼거나 나누어 최소공약수를 찾아내는 방법이다.
- `gcd_sub(a, b)`: a와 b를 서로에 대해 빼면서 최대공약수를 찾는 방법
```python
def gcd_sub(a, b):
	while a*b != 0:
		if a>b:
			a -= b
		else:
			b -= a
	return a+b
```

- `gcd_mod(a, b)`: a와 b를 서로 나눈 나머지를 통해 최대공약수를 찾는 방법
```python
def gcd_mod(a, b):
	while a*b != 0:
		a, b = b%a, a
	return b
```

- `gcd_rec(a, b)`: `gcd_sub(a, b)`나 `gcd_mod(a, b)`를 재귀함수의 형태로 표현
```python
def gcd_rec(a, b):
	if a*b == 0:
		return a+b
	else:
		return gcd_rec(b%a, a)
```

`gcd_sub(a, b)`의 경우, b가 1이라면 a를 1만큼 계속 빼게 된다. 따라서, `gcd_sub(a,b)`의 WTC는 a를 1씩 빼서 0이 되는 횟수인 **a**가 된다.

반면, `gcd_mod(a, b)`는 다르다.
먼저, a>b라는 전제 하에 a%b ≤ $\frac{a}{2}$는 반드시 성립한다. (이해가 안 된다면 선분을 그어서 확인해보자.)
그렇기 때문에 `gcd_mod(a, b)`의 WTC는 $2log_{2}{a}$가 된다.

따라서 `gcd_sub(a, b)`보다 `gcd_mod(a, b)`가 훨씬 빠르다.

위 예시의 `gcd_rec(a, b)`는 `gcd_mod(a, b)`를 재귀함수 형태로 구현한 것이므로 수행시간이 같다.

> [!info] 최대공약수(LCM)을 구하는 방법
>  두 수 a와 b의 최대공약수는 `(a*b)//gcd(a,b)`를 통해 얻을 수 있다.


## 입력의 크기(input size)
입력의 크기(input size)는 입력받는 값의 개수로, 암묵적으로 **n**이라 표현한다.
위에서 다룬 gcd의 input size는 a와 b의 값을 받기 때문에 $n = 2$이다.

```python
def arrayMax(A, n) # A는 배열이며 n은 배열 A의 크기이다.
	currentMax = A[0]
	for i in range(n):
		if currentMax < A[i]:
			currentMax = A[i]
	return currentMax
```

위 함수는 단순하게 배열 속 모든 원소들을 비교하며 최대값을 찾아내는 알고리즘이다.
당연히도 위 알고리즘은 A의 크기가 커질수록(= 입력값이 커질수록) 연산 횟수가 증가한다.

> [!abstract] 입력의 크기와 알고리즘 수행시간의 관계
>   입력의 크기와 알고리즘 수행시간은 상관관계를 갖고 있다. 대부분 입력의 크기가 커지면 처리해야 할 값의 양도 많아지기 때문에 알고리즘의 수행시간도 증가한다.


## 계산모델(RAM)
알고리즘의 수행시간은 알고리즘이 실행되는 컴퓨터의 영향을 크게 받는다.
따라서 알고리즘의 수행시간을 비교하기 위해서 우리는 "**계산모델**"이라는 가상의 컴퓨터 환경을 가정하고
그 환경에서 수행되는 알고리즘의 수행시간을 비교한다.

- ==**계산모델**==(RAM : Random Access Machine): 어떤 기본연산을 제공할지 지정해둔 가상의 컴퓨터 모델.
- ==**기본연산**==: 단위시간(= 1)에 수행할 수 있는 연산

**계산모델**은 가상의 컴퓨터로 CPU, 램(메모리), 기본연산의 모음으로 이루어져 있다.
계산모델은 가상의 컴퓨터이기 때문에 이상적인 연산 환경을 전제로 한다.

- 계산모델의 전제
	1. CPU는 기본연산들을 단위시간(= 1)에 처리할 수 있다.
	2. 메모리는 무한하게 많은 인덱스(≒ 용량)을 가지고 있으며 값의 크기와 상관없이 자유롭게 저장할 수 있다.

- 기본연산의 모음
	- 복사연산: `A = B`
	- 사칙연산: +, -. ×, ÷
	- 비교연산: <, >, ≤, ≥
	- 논리연산: `and`, `or`, `not`, `True`, `False`
	- 비트연산: &, |, !, ^

> [!note] 덧셈/뺄셈과 곱셈/나눗셈
> 실제 컴퓨터에서의 곱셈과 나눗셈은 덧셈과 뺄셈의 연속이기 때문에 같은 단위시간 내에 처리할 수 없다.
> 하지만 계산모델은 가상의 컴퓨터이기 때문에 계산의 용이성을 위해 단위시간 내에 계산할 수 있다고 전제한다.


## 가상코드(Pseudo Code)
계산모델은 가상의 컴퓨터이기 때문에 실제 프로그래밍 언어의 엄격한 문법을 지키며 코드를 작성할 필요가 없다.
그렇기 때문에 우리는 직관적으로 작성하고 이해할 수 있는 가상의 코드를 작성하여 이를 계산모델로 시뮬레이션한다.

이러한 가상의 직관적인 코드를 **가상코드(Pseudo Code)**라고 한다.

